{"version":3,"file":"static/js/485.6ffd57c8.chunk.js","mappings":"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","sources":["../node_modules/@strike-protocols/solana-wallet-adapter/src/strikewallet.ts"],"sourcesContent":["\nimport {\n    Blockhash, Connection, Message,\n    PublicKey,\n    SIGNATURE_LENGTH_IN_BYTES, Signer, Transaction,\n    TransactionInstruction,\n    TransactionSignature\n} from \"@solana/web3.js\";\nimport bs58 from \"bs58\";\nimport {v4 as uuidv4} from \"uuid\";\n\n\ninterface Connected {\n    publicKey: PublicKey;\n}\n\ninterface SendTransaction {\n    identifier: string;\n    signature: TransactionSignature;\n}\n\ninterface SerializableSignaturePubkeyPair {\n    signature: string;\n    pubkey: string;\n}\n\ninterface SignTransaction {\n    identifier: string;\n    signatures: SerializableSignaturePubkeyPair[];\n    feePayer: string;\n    recentBlockhash: Blockhash;\n    message: string;\n}\n\ninterface StrikeWalletMessage {\n    type: 'connected' | 'sendTransaction' | 'signTransaction';\n    error?: string;\n    connected?: Connected;\n    sendTransaction?: SendTransaction;\n    signTransaction?: SignTransaction;\n}\n\ninterface PendingTransactions {\n    [hash: string]: SendTransaction | SignTransaction | null\n}\n\ninterface PendingTransactionErrors {\n    [hash: string]: Error | null\n}\n\ninterface SerializableInstruction {\n    data: string,\n    accountMetas: {address: string, signer: boolean, writable: boolean}[],\n    programId: string\n}\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0)\n\nexport interface SignerOptions {\n    signers?: Signer[];\n}\n\nexport class StrikeWallet {\n    isLoggedIn: boolean;\n    url = 'https://wallet.strikeprotocols.com';\n    private _pendingTransactions: PendingTransactions;\n    private _pendingTransactionErrors: PendingTransactionErrors;\n    private _timers: number[];\n    private _wallet: Window | null;\n    private _connecting: boolean;\n    private _publicKey: PublicKey | null;\n\n    constructor() {\n        this.isLoggedIn = false\n        this._pendingTransactions = {}\n        this._pendingTransactionErrors = {}\n        this._timers = []\n        this._wallet = null;\n        this._connecting = false\n        this._publicKey = null\n\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data as StrikeWalletMessage)\n        })\n    }\n\n    async connect(url: string | null): Promise<PublicKey> {\n        try {\n            this.url = url || this.url\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true\n            this._wallet = window.open(connectUrl, `strike-wallet-${origin}`, \"height=800,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false\n                throw new Error(\"Unable to connect to wallet\")\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet!.closed) {\n                    this.cleanUp();\n                } else if (this._wallet) {\n                    this._wallet.postMessage({type: 'heartbeat'}, this.url)\n                }\n            }, 100));\n            return new Promise<PublicKey>((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey!)\n                    } else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Strike\"))\n                    }\n                }, 100);\n                this._timers.push(timer)\n            })\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public cleanUp = () => {\n        [...this._timers].forEach(t => this.clearTimer(t));\n        const wallet = this._wallet;\n        if (wallet) {\n            wallet.close()\n        }\n        this._wallet = null\n    }\n\n    public async signTransaction(transaction: Transaction): Promise<Transaction> {\n        this.verifyCanSignRequests([transaction])\n        try {\n            return this.signOneTransaction(transaction);\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {\n        this.verifyCanSignRequests(transactions)\n        try {\n            return Promise.all(transactions.map(transaction => {\n                return this.signOneTransaction(transaction);\n            }))\n        } catch (error: any) {\n            throw error;\n        }\n    }\n\n    public async sendTransaction(\n        transaction: Transaction,\n        connection: Connection,\n        options?: SignerOptions,\n    ): Promise<TransactionSignature> {\n        try {\n            const wallet = this._wallet;\n            if (!wallet) throw new Error(\"Not Connected\");\n\n            const transactionIdentifier = uuidv4()\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n\n            if (signers && signers!.length > 0) {\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null\n                        signers?.length && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature!.toString('base64')\n                                    }\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature)\n                                pendingTransactionError && reject(pendingTransactionError)\n                            }\n                        }, 100);\n                        this._timers.push(timer)\n                    }).catch((error) => {\n                        reject(error)\n                        throw error;\n                    })\n                })\n            } else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n                return new Promise<TransactionSignature>((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SendTransaction\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature)\n                            pendingTransactionError && reject(pendingTransactionError)\n                        }\n                    }, 100);\n                    this._timers.push(timer)\n                })\n            }\n        } catch (error) {\n            throw error;\n        }\n    }\n\n\n    private clearTimer = (timer: number) => {\n        this._timers = this._timers.filter(t => t != timer)\n        window.clearInterval(timer);\n    }\n\n    private instructionsToSerializableInstructions = (instructions: TransactionInstruction[]): SerializableInstruction[] => instructions.map(i => {\n        return {\n            'programId': i.programId.toBase58(),\n            'accountMetas': i.keys.map(k => {\n                return {\n                    address: k.pubkey.toBase58(),\n                    signer: k.isSigner,\n                    writable: k.isWritable,\n                }\n            }),\n            'data': window.btoa(String.fromCharCode(...i.data)),\n        }\n    })\n\n    private buildTransaction(pendingTransaction: SignTransaction): Transaction {\n        let message = Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message!), c => c.charCodeAt(0))))\n        return Transaction.populate(\n            message,\n            Array.from({length: message.header.numRequiredSignatures}, (_v, i) => {\n                let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58())\n                return bs58.encode(sigPubkeyPair\n                    ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                    : DEFAULT_SIGNATURE_BUFFER\n                )\n            })\n        )\n    }\n\n    private verifyCanSignRequests(transactions: Transaction[]) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Strike does not support this signing mode\")\n            }\n        })\n    }\n\n    private signOneTransaction(transaction: Transaction, transactionIdentifier = uuidv4()): Promise<Transaction> {\n        const wallet = this._wallet;\n        if (!wallet) throw new Error(\"Not Connected\");\n\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions)\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise<Transaction>((resolve, reject) => {\n            wallet.postMessage({type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier }}, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier] as SignTransaction\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier]\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer)\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction))\n                    pendingTransactionError &&  reject(pendingTransactionError)\n                }\n            }, 100);\n            this._timers.push(timer)\n        });\n    }\n\n    private handleWalletMessage = (data: StrikeWalletMessage) => {\n        if (data.type == \"connected\") {\n            this._connecting = false;\n            if (!data.error) {\n                this.isLoggedIn = true;\n                if (data.connected?.publicKey) {\n                    this._publicKey = new PublicKey(data.connected.publicKey);\n                }\n            }\n        } else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n            const transactionIdentifier = data.sendTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = new Error(data.error);\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null\n                }\n            }\n        } else if (data.type == \"signTransaction\") {\n            const transactionIdentifier = data.signTransaction?.identifier\n            if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                if (data.error) {\n                    this._pendingTransactionErrors[transactionIdentifier] = new Error(data.error);\n                } else {\n                    this._pendingTransactions[transactionIdentifier] = data.signTransaction || null\n                }\n            }\n        }\n    }\n}\n"],"names":["DEFAULT_SIGNATURE_BUFFER","Buffer","alloc","SIGNATURE_LENGTH_IN_BYTES","fill","StrikeWallet","url","cleanUp","_timers","forEach","t","clearTimer","wallet","_wallet","close","timer","filter","window","clearInterval","instructionsToSerializableInstructions","instructions","map","i","programId","toBase58","keys","k","address","pubkey","signer","isSigner","writable","isWritable","btoa","String","fromCharCode","data","handleWalletMessage","type","_connecting","error","isLoggedIn","connected","_a","publicKey","_publicKey","PublicKey","includes","transactionIdentifier","sendTransaction","_b","identifier","_pendingTransactions","_pendingTransactionErrors","Error","signTransaction","_c","this","addEventListener","e","origin","encodeURIComponent","location","connectUrl","open","push","setInterval","closed","postMessage","Promise","resolve","reject","transaction","verifyCanSignRequests","signOneTransaction","transactions","all","connection","options","uuidv4","signers","undefined","length","then","walletTransaction","partialSign","sendFinalTransaction","signaturePubkeyPairs","signatures","sp","signature","toString","pendingTransaction","pendingTransactionError","catch","message","Message","from","Uint8Array","atob","c","charCodeAt","Transaction","Array","header","numRequiredSignatures","_v","sigPubkeyPair","find","s","accountKeys","bs58","encode","some","buildTransaction"],"sourceRoot":""}